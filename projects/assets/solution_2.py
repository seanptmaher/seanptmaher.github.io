from __future__ import print_function
import math

# euclid's algo, implemented with division
def gcd(a, b):
    if a == 0 or b == 0:
        return 1

    if a > b:
        a, b = b, a
        
    while b != 0:
        a, b = b, (a % b)
    return int(a)
        

def solution(dims, hero_orig, guard_orig, range):
    ''' 
    This function will create a large grid of points centered around the hero 
    (as in hero will be placed at (0,0) and we will cycle through the grid, and
    calculate the number of unique slopes at which we can hit a guard, but not a player. 
    
    the grid will be generated by mirroring the grid on its borders until it is larger than range.
    '''

    # grid is List[Tuple(x,y)]
    grid = [] 

    hero = (0, 0, "hero")
    guard = (guard_orig[0] - hero_orig[0], guard_orig[1] - hero_orig[1], "guard")
    grid.append(hero)
    grid.append(guard)

    left_wall = -hero_orig[0]
    right_wall = dims[0] - hero_orig[0]
    down_wall = -hero_orig[1]
    up_wall = dims[1] - hero_orig[1]

    done = False
    def mirror(point):
        '''
        point = tuple of form (x, y)
        orientation = one of {"right", "up", "left", "down"} (this is the axis of reflection of the box)
        reflection = location of the axis of reflection (for example, ("top", 23) means to reflect along the 
                    axis y = 23.

        returns tuple[int, int] of 
        '''

        # y coord stays same, x = x + (abs(reflection - x) * 2)
        if orientation == "right":
            return ((point[0] + (abs(reflection - point[0]) * 2)), point[1], point[2])

        # y coord stays same, x = x - (abs(reflection - x) * 2)
        elif orientation == "left":
            return ((point[0] - (abs(reflection - point[0]) * 2)), point[1], point[2])

        # x coord stays same, y = y + (abs(reflection - y) * 2)
        elif orientation == "up":
            return (point[0], (point[1] + (abs(reflection - point[1]) * 2)), point[2])

        # x coord stays same, y = y - (abs(reflection - y) * 2)
        elif orientation == "down":
            return (point[0], (point[1] - (abs(reflection - point[1]) * 2)), point[2])

    #done mirror func -------------------------------------------------------
    right_done = False
    up_done = False

    orientation = None
    reflection = None

    while not right_done:
        orientation = "right"
        reflection = right_wall
        grid += map(mirror, grid)
        right_wall += abs(left_wall - right_wall)
        
        if abs(right_wall) > range:
            right_done = True

    orientation = "left"
    reflection = left_wall
    grid += map(mirror, grid)
    left_wall -= abs(left_wall - right_wall)

    while not up_done:
        orientation = "up"
        reflection = up_wall
        grid += map(mirror, grid)
        up_wall += abs(up_wall - down_wall)

        if abs(up_wall) > range:
            up_done = True

    orientation = "down"
    reflection = down_wall
    grid += map(mirror, grid)
    down_wall -= abs(up_wall - down_wall)

    #print(grid)

    # get 4 hash tables (one for each quadrant of the grid) and fill them up with
    # key = (slope x, slope y) after reducing the fraction via gcd
    # value = (distance, type)  where type is one of {"hero", "guard"}


    quads = {
        (True, True)   : {}, # positive, positive
        (False, True)  : {}, # negative, positive
        (False, False) : {}, # etc.
        (True, False)  : {}
    }

    # the axes will be included in the positive quadrants -- as will be determined here
    for i in grid:
        # skip origin
        if i[0] == 0 and i[1] == 0:
            continue

        # slope tuple
        div = abs(gcd(i[0], i[1]))

        if i[0] == 0:
            st = (0, 1)
        elif i[1] == 0:
            st = (1, 0)
        else:
            st = (i[0] // div, i[1] // div)

        distance = math.sqrt((i[0]**2) + (i[1]**2))

        quadrant = quads[(i[0] >= 0, i[1] >= 0)]
        if st not in quadrant:
            quadrant[st] = (distance, i[2]) 
                                            
        else:
            assert(quadrant[st][1] != i[2] or quadrant[st][0] != distance)
            if quadrant[st][0] > distance:
                quadrant[st] = (distance, i[2])


    # print("Quadrant 1:")
    # print(quads[(True, True)])
    # print("Quadrant 2:")
    # print(quads[(False, True)])
    # print("Quadrant 3:")
    # print(quads[(False, False)])
    # print("Quadrant 4:")
    # print(quads[(True, False)])

    counter = 0
    for i in quads.values(): # for each quadrant
        # we have already deduplicated the slopes based on smallest distance
        for j in i.values():
            if j[1] == "guard" and j[0] <= range:
#                print("increment")
                counter += 1
            
    return counter

print(solution([3,2], [1,1], [2,1], 4))
print(solution([300,275], [150,150], [185,100], 500))
print(solution([3,2], [1,1], [2,1], 500))
